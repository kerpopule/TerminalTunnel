<claude-mem-context>
# Recent Activity

<!-- This section is auto-generated by claude-mem. Edit content outside the tags. -->

*No recent activity*
</claude-mem-context>

## Onboarding Detection (ClaudeCodeSetup.tsx)

**CRITICAL - DO NOT CHANGE THIS APPROACH**

Claude Code detection **MUST use Tauri command**, NOT server API.

### Why
- Server API fails because Express server (port 3456) isn't ready when frontend loads
- Tauri commands are instant - Rust process is always available
- Server API approach has been tried multiple times and ALWAYS breaks

### How It Works
1. **Rust command** in `src-tauri/src/lib.rs`:
   ```rust
   #[tauri::command]
   fn is_claude_code_installed() -> bool {
       let home = std::env::var("HOME").unwrap_or_default();
       let settings_path = std::path::Path::new(&home).join(".claude").join("settings.json");
       settings_path.exists()
   }
   ```

2. **Frontend** calls via `invoke()`:
   ```typescript
   import { invoke } from '@tauri-apps/api/core';
   const installed = await invoke<boolean>('is_claude_code_installed');
   ```

### DO NOT
- Use `/api/claude-code/detect` endpoint
- Add polling/retry logic for server API
- Add visibility checks for server API timing

**Fix applied Jan 2026**: Switched from broken server API to direct Tauri command.

---

## claude-mem Detection and Installation

**SAME RULE - Use Tauri command, NOT server API**

### Detection
```rust
#[tauri::command]
fn is_claude_mem_installed() -> bool {
    let home = std::env::var("HOME").unwrap_or_default();
    let worker_path = std::path::Path::new(&home)
        .join(".claude-mem")
        .join("plugin")
        .join("scripts")
        .join("worker-service.cjs");
    worker_path.exists()
}
```

### Installation
The `/api/claude-mem/install` endpoint checks if already installed first.
If worker-service.cjs exists, it just starts the worker and returns success.
This prevents git clone failing on existing directory.