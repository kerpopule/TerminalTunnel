import * as pty from 'node-pty';
import { io, Socket } from 'socket.io-client';
import { v4 as uuidv4 } from 'uuid';
import os from 'os';

interface TerminalDimensions {
  cols: number;
  rows: number;
}

interface PtySession {
  id: string;
  pty: pty.IPty;
  sockets: Set<string>;
  dataHandlers: Map<string, (data: string) => void>;
  dataDisposable: pty.IDisposable | null;  // Track the onData disposable
  lastActivity: number;
  createdAt: number;
  scrollbackBuffer: string[];  // Circular buffer for terminal history
  scrollbackSize: number;      // Current size in bytes
  clientDimensions: Map<string, TerminalDimensions>;  // Track dimensions per socket
  effectiveDimensions: TerminalDimensions;  // Current PTY dimensions (active client's dimensions)
  activeSocketId: string | null;  // Which client is actively typing - their dimensions take priority
  // Data batching to prevent escape sequence fragmentation
  pendingData: string;                      // Batched data waiting to send
  batchTimeout: ReturnType<typeof setTimeout> | null;  // Timer for flushing batch
}

// Callback type for terminal data with terminalId
type TerminalDataCallback = (terminalId: string, data: string) => void;

const SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes of inactivity
const MAX_SCROLLBACK_BYTES = 50 * 1024; // 50KB scrollback buffer per session
// Data batching interval - coalesces rapid PTY output to prevent escape sequence fragmentation
// 16ms = ~60fps, balances responsiveness with better sequence grouping for tunneled connections
const DATA_BATCH_INTERVAL_MS = 16;

export class PtyManager {
  private sessions: Map<string, PtySession> = new Map();
  private socketSessions: Map<string, string> = new Map();
  private cleanupInterval: NodeJS.Timeout;
  private activeTerminals = new Map<string, PtySession>();
  private sidecarSocket: Socket | null = null;

  constructor() {
    // Clean up inactive sessions every 5 minutes
    this.cleanupInterval = setInterval(() => {
      this.cleanupInactiveSessions();
    }, 5 * 60 * 1000);

    // Connect to PTY sidecar
    this.connectToSidecar();
  }

  private connectToSidecar() {
    this.sidecarSocket = io('http://localhost:3457');

    this.sidecarSocket.on('connect', () => {
      console.log('Connected to PTY sidecar');
    });

    this.sidecarSocket.on('disconnect', () => {
      console.log('Disconnected from PTY sidecar');
    });

    this.sidecarSocket.on('pty-created', (data) => {
      const { sessionId, pid } = data;
      console.log(`PTY created for session ${sessionId}, PID: ${pid}`);
      // The session should already exist as a mock session
    });

    this.sidecarSocket.on('pty-data', (data) => {
      const { sessionId, data: ptyData } = data;
      this.sendDataToSockets(sessionId, ptyData);
    });

    this.sidecarSocket.on('pty-exit', (data) => {
      const { sessionId } = data;
      console.log(`PTY exited for session ${sessionId}`);
      this.destroySession(sessionId);
    });

    this.sidecarSocket.on('pty-error', (data) => {
      const { sessionId, error } = data;
      console.error(`PTY error for session ${sessionId}:`, error);
    });
  }

  /**
   * Create a new PTY session for a specific terminal
   */
  async createSession(cols: number, rows: number, socketId: string): Promise<string | null> {
    const sessionId = uuidv4();

    // Create a mock session first
    const mockSession: PtySession = {
      id: sessionId,
      pty: {
        pid: 12345, // Mock PID
        kill: () => {
          if (this.sidecarSocket) {
            this.sidecarSocket.emit('destroy-pty', { sessionId });
          }
        },
        resize: (cols, rows) => {
          if (this.sidecarSocket) {
            this.sidecarSocket.emit('pty-resize', { sessionId, cols, rows });
          }
        },
        write: (data: string) => {
          if (this.sidecarSocket) {
            this.sidecarSocket.emit('pty-input', { sessionId, input: data });
          }
        },
        onData: () => {}, // Will be handled by sidecar socket events
        onExit: () => {}, // Will be handled by sidecar socket events
      } as any,
      sockets: new Set([socketId]),
      dataHandlers: new Map(),
      lastActivity: Date.now(),
      createdAt: Date.now(),
      scrollbackBuffer: [],
      clientDimensions: new Map([[socketId, { cols, rows }]]),
      effectiveDimensions: { cols, rows },
      activeSocketId: socketId,
      pendingData: '',
      batchTimeout: null,
    };

    this.sessions.set(sessionId, mockSession);
    this.socketSessions.set(socketId, sessionId);

    // Request PTY creation from sidecar
    if (this.sidecarSocket) {
      this.sidecarSocket.emit('create-pty', { sessionId, cols, rows });
    } else {
      console.error('Sidecar socket not connected');
      return null;
    }

    console.log(`Requested PTY creation for session ${sessionId}`);
    return sessionId;
  }

    // Check if we can run a simple command
    try {
      const { execSync } = require('child_process');
      const result = execSync('echo "test"', { encoding: 'utf8', timeout: 1000 });
      console.log(`Simple exec test: success - ${result.trim()}`);
    } catch (e) {
      console.log(`Simple exec test: failed - ${e.message}`);
    }

    // Add a small delay to ensure environment is ready
    await new Promise(resolve => setTimeout(resolve, 500));

    try {
      // Use login shell flags for proper initialization
      const spawnArgs = process.platform === 'darwin' ? [shell, '-l'] : [shell];
      console.log(`Spawning PTY with args:`, spawnArgs);
      const ptyProcess = pty.spawn(spawnArgs[0], spawnArgs.slice(1), {
        name: 'xterm-256color',
        cols,
        rows,
        cwd: home,
        env: {
          ...process.env,  // Inherit full environment for proper shell config
          TERM: 'xterm-256color',
          HOME: home,
          SHELL: shell,
          LANG: 'en_US.UTF-8'
        }
      });
      console.log(`PTY process spawned successfully, PID: ${ptyProcess.pid}`);

      const session: PtySession = {
        id: sessionId,
        pty: ptyProcess,
        sockets: new Set([socketId]),
        dataHandlers: new Map(),
        dataDisposable: null,
        lastActivity: Date.now(),
        createdAt: Date.now(),
        scrollbackBuffer: [],
        scrollbackSize: 0,
        clientDimensions: new Map([[socketId, { cols, rows }]]),
        effectiveDimensions: { cols, rows },
        activeSocketId: socketId,  // Creator is initially active
        // Initialize data batching state
        pendingData: '',
        batchTimeout: null,
      };

      this.sessions.set(sessionId, session);

      // Set up PTY data listener IMMEDIATELY to capture initial shell prompt
      // This must happen before any data can be output by the shell
      session.dataDisposable = ptyProcess.onData((data) => {
        session.lastActivity = Date.now();

        // Append to scrollback buffer (circular buffer with size limit)
        session.scrollbackBuffer.push(data);
        session.scrollbackSize += data.length;

        // Trim buffer if it exceeds max size
        while (session.scrollbackSize > MAX_SCROLLBACK_BYTES && session.scrollbackBuffer.length > 1) {
          const removed = session.scrollbackBuffer.shift();
          if (removed) {
            session.scrollbackSize -= removed.length;
          }
        }

        // BATCH data instead of immediate emit
        // This prevents escape sequences from being fragmented across WebSocket messages
        session.pendingData += data;

        // If no batch timer running, start one
        if (!session.batchTimeout) {
          session.batchTimeout = setTimeout(() => {
            session.batchTimeout = null;
            if (session.pendingData.length > 0) {
              const batchedData = session.pendingData;
              session.pendingData = '';

              // Route batched data to all registered handlers
              for (const [key, h] of session.dataHandlers) {
                try {
                  h(batchedData);
                } catch (err) {
                  console.error(`Error in data handler ${key}:`, err);
                }
              }
            }
          }, DATA_BATCH_INTERVAL_MS);
        }
      });

      // Handle PTY exit
      ptyProcess.onExit(({ exitCode }) => {
        console.log(`Session ${sessionId} exited with code ${exitCode}`);
        this.sessions.delete(sessionId);
      });

      return sessionId;
    } catch (error) {
      console.error('Failed to create PTY session:', error);
      console.error('Error details:', error.message, error.code, error.errno);
      console.error('Process env:');
      console.error('  SHELL:', process.env.SHELL);
      console.error('  PATH (first 200 chars):', process.env.PATH?.substring(0, 200));

      // Fallback: Create a mock PTY session that simulates basic terminal functionality
      console.log('Creating mock PTY session as fallback...');
      return this.createMockSession(cols, rows, socketId);
    }
  }

  /**
   * Create a new terminal for a socket with a specific terminalId
   */
  async createTerminal(terminalId: string, socketId: string, cols: number, rows: number): Promise<string | null> {
    const sessionId = await this.createSession(cols, rows, socketId);
    if (!sessionId) {
      return null;
    }

    // Track this terminal for the socket
    if (!this.socketTerminals.has(socketId)) {
      this.socketTerminals.set(socketId, new Map());
    }
    this.socketTerminals.get(socketId)!.set(terminalId, sessionId);

    console.log(`Created terminal ${terminalId} -> session ${sessionId} for socket ${socketId}`);
    return sessionId;
  }

  /**
   * Destroy a specific terminal
   */
  destroyTerminal(terminalId: string, socketId: string): void {
    const socketTerminals = this.socketTerminals.get(socketId);
    if (!socketTerminals) return;

    const sessionId = socketTerminals.get(terminalId);
    if (!sessionId) return;

    // Remove terminal from socket's map
    socketTerminals.delete(terminalId);
    if (socketTerminals.size === 0) {
      this.socketTerminals.delete(socketId);
    }

    // Remove data handler for this terminal
    const handlers = this.terminalDataHandlers.get(socketId);
    if (handlers) {
      handlers.delete(terminalId);
      if (handlers.size === 0) {
        this.terminalDataHandlers.delete(socketId);
      }
    }

    // Detach socket from session
    const session = this.sessions.get(sessionId);
    if (session) {
      session.sockets.delete(socketId);
      session.dataHandlers.delete(socketId);

      // If no sockets left, kill the session immediately
      if (session.sockets.size === 0) {
        console.log(`Killing orphaned session ${sessionId} for terminal ${terminalId}`);
        this.killSession(sessionId);
      }
    }

    console.log(`Destroyed terminal ${terminalId} for socket ${socketId}`);
  }

  /**
   * Get the sessionId for a specific terminal
   */
  getSessionForTerminal(terminalId: string, socketId: string): string | null {
    const socketTerminals = this.socketTerminals.get(socketId);
    if (!socketTerminals) return null;
    return socketTerminals.get(terminalId) || null;
  }

  hasSession(sessionId: string): boolean {
    return this.sessions.has(sessionId);
  }

  attachSocket(sessionId: string, socketId: string, dimensions?: TerminalDimensions): void {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.sockets.add(socketId);
      session.lastActivity = Date.now();
      // Track this client's dimensions if provided
      if (dimensions) {
        session.clientDimensions.set(socketId, dimensions);
      }
    }
  }

  /**
   * Attach a socket to an existing session for a specific terminal
   */
  attachTerminal(terminalId: string, sessionId: string, socketId: string, dimensions?: TerminalDimensions): boolean {
    if (!this.hasSession(sessionId)) {
      return false;
    }

    // Track this terminal for the socket
    if (!this.socketTerminals.has(socketId)) {
      this.socketTerminals.set(socketId, new Map());
    }
    this.socketTerminals.get(socketId)!.set(terminalId, sessionId);

    this.attachSocket(sessionId, socketId, dimensions);
    console.log(`Attached terminal ${terminalId} -> session ${sessionId} for socket ${socketId}`);
    return true;
  }

  detachSocket(sessionId: string, socketId: string): TerminalDimensions | null {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.sockets.delete(socketId);
      session.dataHandlers.delete(socketId);
      session.clientDimensions.delete(socketId);

      // Keep activeSocketId even if active client disconnects
      // Dimensions stay fixed - whoever created it gets it
      // The creator can resume control when they reconnect
    }
    return null;
  }

  /**
   * Detach all terminals for a socket
   */
  detachAllTerminals(socketId: string): void {
    const socketTerminals = this.socketTerminals.get(socketId);
    if (!socketTerminals) return;

    // Detach from all sessions
    for (const [terminalId, sessionId] of socketTerminals) {
      this.detachSocket(sessionId, socketId);
      console.log(`Detached terminal ${terminalId} from session ${sessionId}`);
    }

    // Clean up tracking
    this.socketTerminals.delete(socketId);
    this.terminalDataHandlers.delete(socketId);
  }

  /**
   * Find an active session for a terminalId from ANY socket
   * This helps coordinate when multiple clients connect simultaneously
   */
  findActiveSessionForTerminal(terminalId: string): string | null {
    // Search all sockets to find one with an active session for this terminalId
    for (const [_socketId, terminals] of this.socketTerminals) {
      const sessionId = terminals.get(terminalId);
      if (sessionId && this.hasSession(sessionId)) {
        return sessionId;
      }
    }
    return null;
  }

  /**
   * Write data directly to a session's PTY
   */
  writeToSession(sessionId: string, data: string): void {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.pty.write(data);
      session.lastActivity = Date.now();
    }
  }

  /**
   * Set up data handler for a specific terminal
   */
  onTerminalData(terminalId: string, socketId: string, handler: TerminalDataCallback): void {
    const sessionId = this.getSessionForTerminal(terminalId, socketId);
    if (!sessionId) {
      console.warn(`No session found for terminal ${terminalId}`);
      return;
    }

    const session = this.sessions.get(sessionId);
    if (!session) return;

    // Track handler
    if (!this.terminalDataHandlers.has(socketId)) {
      this.terminalDataHandlers.set(socketId, new Map());
    }
    this.terminalDataHandlers.get(socketId)!.set(terminalId, handler);

    // NOTE: PTY data listener is set up in createSession() to capture initial shell prompt
    // Here we only register the handler that will receive the data

    // Track in session's handlers - wrapper that includes terminalId
    session.dataHandlers.set(`${socketId}:${terminalId}`, (data) => {
      try {
        handler(terminalId, data);
      } catch (err) {
        console.error(`Error in terminal handler ${terminalId}:`, err);
      }
    });
  }

  // Legacy method for backward compatibility
  onData(sessionId: string, handler: (data: string) => void): void {
    const session = this.sessions.get(sessionId);
    if (!session) return;

    // Remove any existing listener first
    const existingHandler = session.dataHandlers.get('primary');
    if (existingHandler) {
      // node-pty doesn't have removeListener, so we track handlers ourselves
    }

    // Set up data handler
    session.pty.onData((data) => {
      session.lastActivity = Date.now();
      handler(data);
    });

    session.dataHandlers.set('primary', handler);
  }

  /**
   * Write to a specific terminal
   */
  writeTerminal(terminalId: string, socketId: string, data: string): void {
    const sessionId = this.getSessionForTerminal(terminalId, socketId);
    if (!sessionId) {
      console.warn(`No session found for terminal ${terminalId}`);
      return;
    }
    this.write(sessionId, data);
  }

  write(sessionId: string, data: string): void {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.lastActivity = Date.now();
      session.pty.write(data);
    }
  }

  /**
   * Calculate dimensions based on active client (who last typed)
   * Falls back to first connected client if no active client
   */
  private calculateActiveClientDimensions(session: PtySession): TerminalDimensions {
    // Use active client's dimensions if available
    if (session.activeSocketId && session.clientDimensions.has(session.activeSocketId)) {
      return session.clientDimensions.get(session.activeSocketId)!;
    }

    // Fallback: use first connected client's dimensions
    if (session.clientDimensions.size > 0) {
      const firstDims = session.clientDimensions.values().next().value;
      if (firstDims) return firstDims;
    }

    // Default fallback
    return { cols: 80, rows: 24 };
  }

  /**
   * Mark a client as active (typing) and update PTY dimensions if needed
   * Returns new dimensions if they changed, null otherwise
   */
  markClientActive(sessionId: string, socketId: string): TerminalDimensions | null {
    const session = this.sessions.get(sessionId);
    if (!session) return null;

    // If this client is already active, no change needed
    if (session.activeSocketId === socketId) {
      return null;
    }

    // Mark this client as active
    session.activeSocketId = socketId;
    console.log(`[markClientActive] Session ${sessionId.slice(0,8)}: active client changed to ${socketId.slice(0,8)}`);

    // Get the new active client's dimensions
    const clientDims = session.clientDimensions.get(socketId);
    if (!clientDims) {
      return null;  // Client hasn't reported dimensions yet
    }

    // Check if dimensions need to change
    if (clientDims.cols !== session.effectiveDimensions.cols ||
        clientDims.rows !== session.effectiveDimensions.rows) {
      session.effectiveDimensions = { ...clientDims };
      session.pty.resize(clientDims.cols, clientDims.rows);
      console.log(`[markClientActive] PTY resized to ${clientDims.cols}x${clientDims.rows} for active client`);
      return session.effectiveDimensions;
    }

    return null;
  }

  /**
   * Resize a specific terminal - tracks per-client dimensions
   * Only applies dimensions if this client is the active typer
   * Returns the effective dimensions if they changed, null otherwise
   */
  resizeTerminal(terminalId: string, socketId: string, cols: number, rows: number): TerminalDimensions | null {
    const sessionId = this.getSessionForTerminal(terminalId, socketId);
    if (!sessionId) {
      console.warn(`No session found for terminal ${terminalId}`);
      return null;
    }

    const session = this.sessions.get(sessionId);
    if (!session) return null;

    // Store this client's dimensions
    session.clientDimensions.set(socketId, { cols, rows });

    // Only resize PTY if this client is the creator (active client)
    // Dimensions are fixed to whoever created the terminal
    if (session.activeSocketId === socketId) {
      // This is the creator - use their dimensions
      if (cols !== session.effectiveDimensions.cols ||
          rows !== session.effectiveDimensions.rows) {
        session.effectiveDimensions = { cols, rows };
        session.pty.resize(cols, rows);
        console.log(`[resizeTerminal] Terminal ${terminalId.slice(0,8)}: creator resized to ${cols}x${rows}`);
        return session.effectiveDimensions;
      }
    }
    // Non-creators can't resize - dimensions stay fixed

    return null;
  }

  /**
   * Get the effective dimensions for a session
   */
  getEffectiveDimensions(sessionId: string): TerminalDimensions | null {
    const session = this.sessions.get(sessionId);
    return session ? session.effectiveDimensions : null;
  }

  resize(sessionId: string, cols: number, rows: number): void {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.effectiveDimensions = { cols, rows };
      session.pty.resize(cols, rows);
    }
  }

  killSession(sessionId: string): void {
    const session = this.sessions.get(sessionId);
    if (session) {
      // Clear batch timer to prevent memory leaks
      if (session.batchTimeout) {
        clearTimeout(session.batchTimeout);
        session.batchTimeout = null;
      }
      session.pendingData = '';
      // Dispose of data handler to prevent memory leaks
      if (session.dataDisposable) {
        session.dataDisposable.dispose();
        session.dataDisposable = null;
      }
      // Clear all handlers
      session.dataHandlers.clear();
      // Kill the PTY process
      try {
        session.pty.kill();
      } catch (err) {
        console.error(`Error killing PTY session ${sessionId}:`, err);
      }
      this.sessions.delete(sessionId);
    }
  }

  killAllSessions(): void {
    for (const [sessionId] of this.sessions) {
      this.killSession(sessionId);
    }
  }

  /**
   * Get all terminals for a socket
   */
  getSocketTerminals(socketId: string): Map<string, string> {
    return this.socketTerminals.get(socketId) || new Map();
  }

  /**
   * Get scrollback buffer for a session (for sending to late-joining clients)
   */
  getScrollback(sessionId: string): string {
    const session = this.sessions.get(sessionId);
    if (!session) return '';
    return session.scrollbackBuffer.join('');
  }

  private cleanupInactiveSessions(): void {
    const now = Date.now();
    for (const [sessionId, session] of this.sessions) {
      // Kill sessions that have been inactive and have no connected sockets
      if (session.sockets.size === 0 && now - session.lastActivity > SESSION_TIMEOUT) {
        console.log(`Cleaning up inactive session ${sessionId}`);
        this.killSession(sessionId);
      }
    }
  }

  /**
   * Create a mock PTY session that simulates terminal behavior without actual PTY
   */
  createMockSession(cols: number, rows: number, socketId: string): string | null {
    const sessionId = uuidv4();

    // Create a mock session that behaves like a PTY
    const mockSession: PtySession = {
      id: sessionId,
      pty: {
        pid: 12345, // Mock PID
        kill: () => {}, // Mock kill
        resize: () => {}, // Mock resize
        write: (data: string) => {
          // Handle user input - simulate basic commands
          this.handleMockCommand(sessionId, data);
        },
        onData: () => {}, // Will be set below
        onExit: () => {}, // Will be set below
      } as any,
      sockets: new Set([socketId]),
      dataHandlers: new Map(),
      lastActivity: Date.now(),
      createdAt: Date.now(),
      scrollbackBuffer: [],
      clientDimensions: new Map([[socketId, { cols, rows }]]),
      effectiveDimensions: { cols, rows },
      activeSocketId: socketId,
      pendingData: '',
      batchTimeout: null,
    };

    this.sessions.set(sessionId, mockSession);
    this.socketSessions.set(socketId, sessionId);

    // Send initial prompt
    setTimeout(() => {
      this.sendDataToSockets(sessionId, '\r\n$ ');
    }, 100);

    console.log(`Created mock PTY session ${sessionId} for ${socketId}`);
    return sessionId;
  }

  /**
   * Handle mock commands in the simulated terminal
   */
  handleMockCommand(sessionId: string, data: string): void {
    const session = this.sessions.get(sessionId);
    if (!session) return;

    // Simple command handling
    const command = data.trim();
    let response = '';

    if (command === '') {
      // Just enter - show new prompt
      response = '\r\n$ ';
    } else if (command === 'ls') {
      response = '\r\nDesktop  Documents  Downloads  Pictures\r\n$ ';
    } else if (command === 'pwd') {
      response = '\r\n/Users/user\r\n$ ';
    } else if (command === 'whoami') {
      response = '\r\nuser\r\n$ ';
    } else if (command === 'echo hello') {
      response = '\r\nhello\r\n$ ';
    } else if (command.startsWith('echo ')) {
      const text = command.substring(5);
      response = `\r\n${text}\r\n$ `;
    } else if (command === 'clear') {
      response = '\x1b[2J\x1b[H$ '; // Clear screen and show prompt
    } else if (command === 'exit' || command === 'quit') {
      response = '\r\nGoodbye!\r\n';
      // Close the session
      setTimeout(() => {
        this.destroySession(sessionId);
      }, 500);
      return;
    } else {
      response = `\r\n${command}: command not found\r\n$ `;
    }

    // Send response with slight delay to simulate processing
    setTimeout(() => {
      this.sendDataToSockets(sessionId, response);
    }, 100 + Math.random() * 200); // Random delay for realism
  }

  destroy(): void {
    clearInterval(this.cleanupInterval);
    this.killAllSessions();
  }
}
